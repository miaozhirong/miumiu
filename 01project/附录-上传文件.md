
### 附：1. 基于SpringMVC的文件上传

#### 1.1. 创建项目

创建新的SpringMVC的项目，即：创建**Maven Project**，**Group Id**是`cn.tedu.spring`，**Artifact Id**是`SPRINGMVC-03-UPLOAD`，然后创建出项目。

#### 1.2. 添加必要的依赖

本项目需要`spring-webmvc`依赖，另，上传功能需要`commons-fileupload`依赖：

	<dependency>
		<groupId>commons-fileupload</groupId>
		<artifactId>commons-fileupload</artifactId>
		<version>1.4</version>
	</dependency>

#### 1.3. 设计页面

在`webapp`下创建`index.html`静态页面，并在页面中添加上传的表单，上传控件是：

	<input type="file" />

> 以上标签还可以配置`multiple="multiple"`，用于批量上传，用户在选择上传的文件时，可以按住Ctrl键一6次选中多个文件最终提交。

实现文件上传时，`<form>`的`method`必须是`post`，并且，必须配置`enctype="multipart/form-data"`。

完整代码例如：

	<form action="" method="post" enctype="multipart/form-data">
		<p>请选择您要上传的文件</p>
		<p><input type="file" /></p>
		<p><input type="submit" value="上传" /><p>
	</form>

#### 1.4. Spring配置

在实现上传之前，需要在Spring的配置文件添加配置：

	<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver" />

在配置时，`<bean>`节点的`id`属性必须是`multipartResolver`。

该`<bean>`节点还可以用于为`CommonsMultipartResolver`的某些属性注入值，但是，不是必要的配置。

#### 1.5. 实现文件上传

用户通过网页可以选择要上传的文件，并提交到服务器端，服务器端需要使用控制器接收用户此次的提交数据的请求，并将数据存储到某个文件中，以完成文件上传。

首先，应该在服务器端创建控制器类`cn.tedu.spring.UploadController`（确保该类在组件扫描范围之内），添加`@Controller`注解，并添加处理请求的方法：

	@RequestMapping("upload.do")
	public String handleUpload() {
		return null;
	}

则前端页面的`<form>`的`action`属性值就必须是`upload.do`。

在控制器中，使用`MultipartFile`类型的参数，它表示客户端提交的文件的数据：

	@RequestMapping("upload.do")
	public String handleUpload(
			MultipartFile file) {
		return null;
	}

由于此处参数的名称是`file`，则前端页面的上传控件的`name`属性值也必须是`file`。

除此以外，还要求在该参数之前使用`@RequestParam("file")`注解：

	@RequestMapping("upload.do")
	public String handleUpload(
		@RequestParam("file") MultipartFile file) {
		return null;
	}

在处理请求的方法中，调用参数`MultipartFile file`的`transferTo(File dest)`方法即可将文件存储下来！

	@RequestMapping("upload.do")
	public String handleUpload(
		@RequestParam("file") MultipartFile file) throws IllegalStateException, IOException {
		File dest = new File("d:/ChengHeng/1.jpg");
		file.transferTo(dest);
		return null;
	}

#### 1.6. 确定上传文件的文件名

	@RequestMapping("upload.do")
	public String handleUpload(
		@RequestParam("file") MultipartFile file) throws IllegalStateException, IOException {
		// 确定上传文件将保存到哪个文件夹
		File parent = new File("d:/ChengHeng");
		
		// 获取上传的文件的原始名称
		String originalFilename = file.getOriginalFilename(); // DAY01.zip
		// 确定上传的文件的扩展名
		String suffix = "";
		int beginIndex = originalFilename.lastIndexOf(".");
		if (beginIndex != -1) {
			suffix = originalFilename.substring(beginIndex);
		}
		// 确定上传的文件最终保存时使用的文件名
		String child = UUID.randomUUID().toString() + suffix;
		
		// 确定上传的文件最终保存时的文件对象
		File dest = new File(parent, child);
		// 执行保存
		file.transferTo(dest);
		return null;
	}

#### 1.7. 确定上传到的文件夹

	@RequestMapping("upload.do")
	public String handleUpload(
		HttpServletRequest request,
		@RequestParam("file") MultipartFile file) throws IllegalStateException, IOException {
		// 通过request对象获取项目部署到的文件夹中的某子级文件夹
		String parentPath 
			= request.getServletContext()
				.getRealPath("upload");
		// 确定上传文件将保存到哪个文件夹
		File parent = new File(parentPath);
		// 确保文件夹是存在的
		if (!parent.exists()) {
			parent.mkdirs();
		}
		
		// 获取上传的文件的原始名称
		String originalFilename = file.getOriginalFilename(); // DAY01.zip
		// 确定上传的文件的扩展名
		String suffix = "";
		int beginIndex = originalFilename.lastIndexOf(".");
		if (beginIndex != -1) {
			suffix = originalFilename.substring(beginIndex);
		}
		// 确定上传的文件最终保存时使用的文件名
		String child = UUID.randomUUID().toString() + suffix;
		
		// 确定上传的文件最终保存时的文件对象
		File dest = new File(parent, child);
		// 执行保存
		file.transferTo(dest);
		return null;
	}

#### 1.8. 关于MutlipartFile中的常用方法

- `boolean isEmpty()`：判断上传的文件是否为空，当没有选择文件，或选择的文件是0字节时为`true`，否则为`false`。

- `String getOriginalFilename()`：获取文件的原始文件名，即在客户端中使用的文件名。

- `long getSize()`：获取文件的大小，以字节为单位。

- `String getContentType()`：获取文件的MIME类型，各扩展名与MIME类型的对应关系可以上网查阅，或在Tomcat的`conf/web.xml`中查找。

- `InputStream getInputStream()`：获取上传文件的输入流，通常用于自定义接收和存储文件，与`transferTo()`不会同时使用。

- `void transferTo(File dest)`：直接存储客户端提交上传的文件。

#### 1.9. 关于MultipartResolver的配置

在使用文件上传时，在Spring的配置文件中配置了`CommonsMultipartResolver`，可以配置的属性有：

- `maxUploadSize`：上传的文件的最大大小，以字节为单位，假设设置值是10M，如果一次性上传5个文件，则5个文件的大小总和不允许超过10M。

- `maxUploadSizePerFile`：上传的单个文件的最大大小，以字节为单位，，假设设置值是10M，如果一次性上传5个文件，则每个文件的大小都不允许超过10M，但是5个文件的总和可能接近50M。

- `defaultEncoding`：默认编码，用于配置客户端在上传表单中提交的其它值（例如同一个表单中的输入框中的数据等）的字符编码。

> 即便配置了`MultipartResolver`的`maxUploadSize`甚至还有`maxUploadSizePerFile`，在编写控制器中处理上传的方法时，仍应该通过`MultipartFile`的`getSize()`方法获取文件大小，并判断文件大小是否在允许的范围之内！因为，配置的`MultipartResolver`是整个上传功能的配置，在同一个项目中，可能有多个上传功能，例如上传头像、上传附件、上传商品图片等，`MultipartResolver`的配置将作用于当前项目中的所有上传功能，所以，设置值可能偏大，而在控制器中是针对某个具体的功能的配置！所以，其实可以不配置`MultipartResolver`，只需要在每个处理上传功能的控制器方法中进行判断即可！当然，如果在配置文件中已经配置了`MultipartResolver`，则可能更早的将某些不符合要求的请求拒绝掉，也是有好处的，但是，如果要配置，一定是配置一个满足所有上传功能的最大值。


### 附2：配置整个项目上传文件的最大大小
在主main配置

	@SpringBootApplication
	@MapperScan("cn.tedu.store.mapper")
	@Configuration
	public class StoreApplication {
	public static void main(String[] args) {
		SpringApplication.run(StoreApplication.class, args);
	}
	@Bean
	public MultipartConfigElement getMultipartConfig() {
		MultipartConfigFactory factory=new MultipartConfigFactory();
		DataSize maxSize=DataSize.ofMegabytes(100L);//整个项目允许上传的文件大小最大为100MB
		factory.setMaxFileSize(maxSize);
		factory.setMaxRequestSize(maxSize);
		return factory.createMultipartConfig();
	}

}